:a(:fruit, :healthy food).
:a(:lemons, :fruit).
:a(:socrates, :Mortal).
:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)
:a(?T1, ?T2) :- :a(?T1, ?T3)
:a(?T2, ?T3) :- :a(?T1, ?T3)
6 facts, w:3, h:3, x:0, y:0
6 facts, w:3, h:3, x:0, y:1
6 facts, w:3, h:3, x:0, y:2
6 facts, w:3, h:3, x:1, y:0
6 facts, w:3, h:3, x:1, y:1
6 facts, w:3, h:3, x:1, y:2
Goal:  :- :likes(:socrates, :lemons)
=======
  c: << :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :likes
Check rule: :likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)
Unify:
  s: :likes(:socrates, :lemons) in env of size 0{}
  d: :likes(?X, ?B) in env of size 0{}
  Comparison:
##Unify:
##  s: :socrates in env of size 0{}
##  d: ?X in env of size 0{}
##  dest is var
##Eval ?X in env of size 0{}
(?X is a var..)
##Eval :socrates in env of size 0{}
1 Match!(free var)
    :socrates == ?X
Unify:
  s: :lemons in env of size 0{}
  d: ?B in env of size 1{?X: :socrates; }
  dest is var
Eval ?B in env of size 1{?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 0{}
0 Match!(free var)
    :lemons == ?B
  Equal!
Adding to queue: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]
Done euler loop
done rule checks, looping
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?B != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
Unify:
  s: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    :healthy food != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
 No match
    ?B != :socrates
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
0 Match!(free var)
    ?B == ?T1
Unify:
  s: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T1: :lemons; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
-2 Match!(free var)
    :healthy food == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-2 Match!(free var)
    ?B == ?T2
Unify:
  s: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
-4 Match!(free var)
    :healthy food == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :healthy food
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :Mortal in env of size 0{}
 No match
    ?T3 != :Mortal
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-8 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-10 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T3: :healthy food; }}[[ground:]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T3: :healthy food; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :healthy food; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :healthy food; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 1{?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 1{?T3: :healthy food; }
  d: :healthy food in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 1{?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 1{?T3: :healthy food; }
  dest is var
Eval ?T2 in env of size 1{?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-12 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-13Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-12    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :Mortal in env of size 0{}
 No match
    ?T3 != :Mortal
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-16 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-17Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-16    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-17Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-16    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-18 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-19Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-18    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-19Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-18    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-31 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-32 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :Mortal in env of size 0{}
 No match
    ?T3 != :Mortal
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-36 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-37Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-36    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-37Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-36    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-38 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-39Unify:
  s: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-38    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
-39Unify:
  s: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-38    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
-42 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
-46Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: :healthy food in env of size 1{?T2: :healthy food; }
  Comparison:
  Equal!
-45    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
-49Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: :healthy food in env of size 1{?T2: :healthy food; }
  Comparison:
  Equal!
-48    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
-52Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: :healthy food in env of size 1{?T2: :healthy food; }
  Comparison:
  Equal!
-51    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :healthy food; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :healthy food; }
  d: ?T1 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: ?T2 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 1{?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 1{?T2: :healthy food; }
-55Unify:
  s: :healthy food in env of size 1{?T2: :healthy food; }
  d: :healthy food in env of size 1{?T2: :healthy food; }
  Comparison:
  Equal!
-54    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-56 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :healthy food; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-57 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-58 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-59 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :healthy food; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 1{?T2: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-60 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-61 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-62 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
-63Unify:
  s: :healthy food in env of size 0{}
  d: :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-62    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :socrates in env of size 0{}
 No match
    ?T1 != :socrates
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-63 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T1: :lemons; }}[[ground:]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-65 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
-79 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
-83Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: :lemons in env of size 1{?T2: :lemons; }
  Comparison:
  Equal!
-82    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
-86Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: :lemons in env of size 1{?T2: :lemons; }
  Comparison:
  Equal!
-85    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
-89Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: :lemons in env of size 1{?T2: :lemons; }
  Comparison:
  Equal!
-88    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: ?T2 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T2: :lemons; }
(?T2 is a var..)
Eval :lemons in env of size 1{?T2: :lemons; }
-92Unify:
  s: :lemons in env of size 1{?T2: :lemons; }
  d: :lemons in env of size 1{?T2: :lemons; }
  Comparison:
  Equal!
-91    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :lemons; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 1{?T2: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-95 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T1: :lemons; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-96 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-98Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-97    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-98Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-97    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :socrates in env of size 0{}
 No match
    ?T1 != :socrates
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-98 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-100Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-99    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-100Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-99    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-100 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-102Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-101    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-102Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-101    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-103 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :lemons; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :lemons; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-104 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-105 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :lemons; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :lemons; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-106 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T2: :lemons; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :lemons; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :lemons; }
  dest is var
Eval ?T1 in env of size 1{?T2: :lemons; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-107 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :lemons; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :lemons; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-108 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 1{?T1: :lemons; }}[[ground:]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :lemons; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :lemons; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :lemons; }
(?T1 is a var..)
Eval :lemons in env of size 1{?T1: :lemons; }
Unify:
  s: :lemons in env of size 1{?T1: :lemons; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :lemons; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :lemons; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :lemons; }
(?T1 is a var..)
Eval :lemons in env of size 1{?T1: :lemons; }
Unify:
  s: :lemons in env of size 1{?T1: :lemons; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T1: :lemons; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :lemons; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :lemons; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 1{?T1: :lemons; }
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 1{?T1: :lemons; }
  dest is var
Eval ?T1 in env of size 1{?T1: :lemons; }
(?T1 is a var..)
Eval :lemons in env of size 1{?T1: :lemons; }
-109Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 1{?T1: :lemons; }
  Comparison:
  Equal!
-108    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  dest is var
Eval ?T2 in env of size 1{?T1: :lemons; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-109 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :socrates in env of size 0{}
 No match
    ?T1 != :socrates
No loop here
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-110 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 1{?T1: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-112Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-111    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-112Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-111    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-112 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T3 in env of size 1{?T2: :lemons; }
  source is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-114Unify:
  s: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-113    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T2 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-114Unify:
  s: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  d: :healthy food in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-113    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-115Unify:
  s: :lemons in env of size 0{}
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-114    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-115 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
-115 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
Unify:
  s: :healthy food in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
-116Unify:
  s: :healthy food in env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }
  d: :healthy food in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-115    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
-116 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
-117Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :healthy food in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-116    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T2: :lemons; ?T3: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T2: :lemons; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
-117 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
-118Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }
  d: :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  Comparison:
  Equal!
-117    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-118Unify:
  s: :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-117    ?T2 == ?B
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
Unify:
  s: :lemons in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-118Unify:
  s: :lemons in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-117    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }
-118 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-119Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-118    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }
-119 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 2{?T1: :lemons; ?T2: :healthy food; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T1 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
-120Unify:
  s: :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  Comparison:
  Equal!
-119    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
-120 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-121Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-120    ?T1 == ?B
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-121Unify:
  s: :lemons in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-120    ?T2 == ?B
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-121Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-120    ?T2 == ?B
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T2 is a var..)
Eval :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-121Unify:
  s: :lemons in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-120    ?T2 == ?B
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-121 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-123 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-123 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-125 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-129 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-131 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-135 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-136Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-135    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-137 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-138Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-137    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-138Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-137    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-139 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-140Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-139    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-140Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-139    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-152 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-153 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-156Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-155    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-156Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-155    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-157 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-158Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-157    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-158Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-157    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-159 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-160Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-159    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-160Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-159    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-163 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-167Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-166    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-170Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-169    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-173Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-172    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-176Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-175    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-177 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-178 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-179 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-180 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-181 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-182 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-183 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-184Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-183    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-184 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-186 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-200 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-204Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-203    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-207Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-206    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-210Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-209    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-213Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-212    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-216 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-217 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-219Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-218    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-219Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-218    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-219 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-221Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-220    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-221Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-220    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-221 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-223Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-222    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-223Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-222    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-224 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-225 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-226 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-227 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-228 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-229 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-230Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-229    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-230 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-231 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-233Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-232    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-233Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-232    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-233 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-235Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-234    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-235Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-234    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-236Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-235    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-236 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-237Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-236    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-236Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-235    ?T1 == ?B
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-236Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-235    ?T1 == ?B
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,0(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:]]) {env:env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
  d: :a(?B, :healthy food) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
  d: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
-236Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
  d: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-235    ?T1 == ?B
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
(?T2 is a var..)
Eval :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }
  d: :healthy food in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :healthy food
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-236 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-238 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-238 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-240 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-244 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-246 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-250 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-251Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-250    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-252 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-253Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-252    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-253Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-252    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-254 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-255Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-254    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-255Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-254    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-267 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-268 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-271Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-270    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-271Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-270    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-272 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-273Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-272    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-273Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-272    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-274 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-275Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-274    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-275Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-274    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-278 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-282Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-281    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-285Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-284    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-288Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-287    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-291Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-290    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-292 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-293 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-294 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-295 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-296 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-297 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-298 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-299Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-298    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-299 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-301 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-315 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-319Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-318    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-322Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-321    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-325Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-324    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-328Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-327    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-331 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-332 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-334Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-333    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-334Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-333    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-334 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-336Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-335    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-336Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-335    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-336 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-338Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-337    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-338Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-337    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-339 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-340 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-341 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-342 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-343 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-344 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-345Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-344    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-345 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-346 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-348Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-347    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-348Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-347    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-348 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-350Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-349    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-350Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-349    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-351Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-350    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-351 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-352Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-351    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-351 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-353 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-353 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-355 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-359 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-361 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-365 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-366Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-365    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-367 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-368Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-367    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-368Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-367    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-369 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-370Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-369    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-370Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-369    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-382 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-383 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-386Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-385    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-386Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-385    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-387 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-388Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-387    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-388Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-387    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-389 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-390Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-389    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-390Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-389    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-393 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-397Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-396    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-400Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-399    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-403Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-402    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-406Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-405    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-407 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-408 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-409 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-410 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-411 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-412 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-413 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-414Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-413    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-414 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-416 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-430 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-434Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-433    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-437Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-436    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-440Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-439    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-443Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-442    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-446 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-447 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-449Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-448    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-449Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-448    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-449 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-451Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-450    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-451Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-450    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-451 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-453Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-452    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-453Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-452    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-454 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-455 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-456 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-457 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-458 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-459 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-460Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-459    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-460 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-461 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-463Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-462    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-463Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-462    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-463 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-465Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-464    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-465Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-464    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-466Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-465    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-466 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-467Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-466    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-466 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-468 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-468 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-470 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-474 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-476 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-480 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-481Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-480    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-482 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-483Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-482    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-483Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-482    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-484 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-485Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-484    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-485Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-484    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-497 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-498 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-501Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-500    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-501Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-500    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-502 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-503Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-502    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-503Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-502    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-504 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-505Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-504    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-505Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-504    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-508 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-512Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-511    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-515Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-514    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-518Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-517    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-521Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-520    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-522 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-523 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-524 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-525 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-526 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-527 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-528 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-529Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-528    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-529 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-531 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-545 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-549Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-548    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-552Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-551    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-555Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-554    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-558Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-557    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-561 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-562 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-564Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-563    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-564Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-563    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-564 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-566Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-565    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-566Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-565    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-566 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-568Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-567    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-568Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-567    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-569 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-570 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-571 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-572 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-573 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-574 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-575Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-574    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-575 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-576 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-578Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-577    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-578Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-577    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-578 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-580Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-579    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-580Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-579    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-581Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-580    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-581 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-582Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-581    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-581 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-583 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-583 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-585 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-589 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-591 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-595 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-596Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-595    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-597 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-598Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-597    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-598Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-597    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-599 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-600Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-599    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-600Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-599    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-612 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-613 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-616Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-615    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-616Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-615    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-617 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-618Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-617    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-618Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-617    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-619 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-620Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-619    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-620Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-619    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-623 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-627Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-626    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-630Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-629    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-633Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-632    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-636Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-635    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-637 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-638 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-639 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-640 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-641 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-642 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-643 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-644Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-643    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-644 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-646 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-660 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-664Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-663    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-667Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-666    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-670Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-669    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-673Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-672    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-676 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-677 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-679Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-678    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-679Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-678    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-679 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-681Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-680    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-681Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-680    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-681 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-683Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-682    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-683Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-682    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-684 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-685 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-686 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-687 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-688 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-689 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-690Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-689    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-690 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-691 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-693Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-692    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-693Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-692    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-693 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-695Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-694    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-695Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-694    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-696Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-695    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-696 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-697Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-696    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-696 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-697Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-696    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-697 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-698Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-697    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-698 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-699Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-698    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-699Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-698    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-699Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-698    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-699 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-700Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-699    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-700 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-701Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-700    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-701 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-702Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-701    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-702 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-704 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-704 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-706 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-710 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-712 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-716 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-717Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-716    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-718 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-719Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-718    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-719Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-718    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-720 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-721Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-720    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-721Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-720    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-733 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-734 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-737Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-736    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-737Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-736    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-738 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-739Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-738    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-739Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-738    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-740 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-741Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-740    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-741Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-740    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-744 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-748Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-747    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-751Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-750    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-754Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-753    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-757Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-756    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-758 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-759 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-760 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-761 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-762 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-763 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-764 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-765Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-764    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-765 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-767 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-781 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-785Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-784    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-788Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-787    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-791Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-790    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-794Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-793    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-797 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-798 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-800Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-799    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-800Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-799    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-800 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-802Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-801    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-802Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-801    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-802 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-804Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-803    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-804Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-803    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-805 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-806 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-807 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-808 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-809 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-810 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-811Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-810    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-811 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-812 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-814Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-813    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-814Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-813    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-814 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-816Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-815    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-816Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-815    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-817Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-816    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-817 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-818Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-817    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-817 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-819 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-819 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-821 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-825 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-827 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-831 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-832Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-831    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-833 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-834Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-833    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-834Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-833    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-835 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-836Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-835    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-836Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-835    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-848 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-849 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-852Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-851    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-852Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-851    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-853 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-854Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-853    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-854Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-853    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-855 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-856Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-855    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-856Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-855    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-859 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-863Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-862    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-866Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-865    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-869Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-868    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-872Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-871    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-873 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-874 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-875 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-876 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-877 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-878 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-879 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-880Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-879    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-880 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-882 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-896 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-900Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-899    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-903Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-902    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-906Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-905    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-909Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-908    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-912 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-913 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-915Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-914    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-915Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-914    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-915 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-917Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-916    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-917Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-916    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-917 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-919Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-918    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-919Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-918    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-920 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-921 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-922 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-923 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-924 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-925 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-926Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-925    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-926 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-927 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-929Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-928    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-929Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-928    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-929 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-931Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-930    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-931Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-930    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-932Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-931    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-932 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-933Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-932    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 2
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?X != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?X != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-932 Match!(free var)
    ?X == ?T1
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-934 Match!(free var)
    :Mortal == ?T2
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-934 Match!(free var)
    ?X == ?T2
Unify:
  s: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
-936 Match!(free var)
    :Mortal == ?T3
  Equal!
  ep.src: 0
  c.src: 1
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-940 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-942 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :healthy food in env of size 0{}
 No match
    ?T3 != :healthy food
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 1{?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 1{?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 1{?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-946 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-947Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-946    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-948 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-949Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-948    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-949Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-948    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-950 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-951Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-950    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-951Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-950    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-963 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-964 Match!(free var)
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T3 != :fruit
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 0{}
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-967Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-966    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-967Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-966    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-968 Match!(free var)
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-969Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-968    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-969Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-968    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 0{}
  dest is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-970 Match!(free var)
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T2, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-971Unify:
  s: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-970    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
-971Unify:
  s: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-970    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-974 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-978Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-977    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-981Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-980    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-984Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-983    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :Mortal; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :Mortal; }
  d: ?T1 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: ?T2 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 1{?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 1{?T2: :Mortal; }
-987Unify:
  s: :Mortal in env of size 1{?T2: :Mortal; }
  d: :Mortal in env of size 1{?T2: :Mortal; }
  Comparison:
  Equal!
-986    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-988 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-989 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-990 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-991 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :Mortal; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 1{?T2: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-992 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-993 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-994 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-995Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-994    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-995 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-997 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 1
  c.src: 4
  ~~  ~~  ~~
  ep.src: 0
  c.src: 4
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 5
  ~~  ~~  ~~
  ep.src: 1
  c.src: 5
  ~~  ~~  ~~
  ep.src: 0
  c.src: 5
  ~~  ~~  ~~
Adding to queue: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-1011 Match!(free var)
    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :lemons
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :fruit
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-1015Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-1014    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-1018Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-1017    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-1021Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-1020    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
 Match(free var)!
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 5
Unify:
  s: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  d: :a(?T2, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: ?T2 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T2: :socrates; }
(?T2 is a var..)
Eval :socrates in env of size 1{?T2: :socrates; }
-1024Unify:
  s: :socrates in env of size 1{?T2: :socrates; }
  d: :socrates in env of size 1{?T2: :socrates; }
  Comparison:
  Equal!
-1023    ?T2 == ?T2
Unify:
  s: ?T3 in env of size 1{?T2: :socrates; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 1{?T2: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 0{}
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 0{}
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
 Match(free var)!
    ?T1 == :fruit
Unify:
  s: ?T3 in env of size 0{}
  d: :healthy food in env of size 0{}
  source is var
Eval ?T3 in env of size 0{}
(?T3 is a var..)
 Match(free var)!
    ?T3 == :healthy food
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1027 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1028 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1030Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1029    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1030Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1029    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1030 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1032Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1031    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1032Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1031    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1032 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 5
  c.src: 4
  ~~  ~~  ~~
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1034Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1033    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1034Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1033    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 0{}
-1035 Match!(free var)
    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :socrates; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-1036 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:lemons, :fruit).2,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:lemons, :fruit) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :lemons in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :lemons in env of size 0{}
-1037 Match!(free var)
    :lemons == ?T1
Unify:
  s: :fruit in env of size 0{}
  d: ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :lemons; ?T2: :socrates; }
(?T3 is a var..)
Eval :fruit in env of size 0{}
-1038 Match!(free var)
    :fruit == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
=======
  c: <<:a(:fruit, :healthy food).1,0(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T2: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:fruit, :healthy food) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 1{?T2: :socrates; }
  Comparison:
Unify:
  s: :fruit in env of size 0{}
  d: ?T1 in env of size 1{?T2: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T2: :socrates; }
(?T1 is a var..)
Eval :fruit in env of size 0{}
-1039 Match!(free var)
    :fruit == ?T1
Unify:
  s: :healthy food in env of size 0{}
  d: ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
  dest is var
Eval ?T3 in env of size 2{?T1: :fruit; ?T2: :socrates; }
(?T3 is a var..)
Eval :healthy food in env of size 0{}
-1040 Match!(free var)
    :healthy food == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 1{?T1: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]
c.ind: 0
c.rule.body.size(): 1
Done q
NO BEES yet PLZ!
Checking cases...
looking for case :a
Check rule: :a(:fruit, :healthy food).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:fruit, :healthy food) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :fruit in env of size 0{}
 No match
    ?T1 != :fruit
No loop here
Check rule: :a(:lemons, :fruit).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:lemons, :fruit) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :lemons in env of size 0{}
 No match
    ?T1 != :lemons
No loop here
Check rule: :a(:socrates, :Mortal).
Unify:
  s: :a(?T1, ?T3) in env of size 1{?T1: :socrates; }
  d: :a(:socrates, :Mortal) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
Unify:
  s: :socrates in env of size 1{?T1: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?T1 == :socrates
Unify:
  s: ?T3 in env of size 1{?T1: :socrates; }
  d: :Mortal in env of size 0{}
  source is var
Eval ?T3 in env of size 1{?T1: :socrates; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == :Mortal
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 1{?T1: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T1 in env of size 1{?T1: :socrates; }
(?T1 is a var..)
Eval :socrates in env of size 1{?T1: :socrates; }
-1041Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 1{?T1: :socrates; }
  Comparison:
  Equal!
-1040    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  dest is var
Eval ?T2 in env of size 1{?T1: :socrates; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1041 Match!(free var)
    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T1, ?T2) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 0{}
  dest is var
Eval ?T1 in env of size 0{}
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1042 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 1{?T1: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T2
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1044Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1043    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1044Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1043    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
Check rule: :a(?T2, ?T3) :- :a(?T1, ?T3)
Unify:
  s: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T2, ?T3) in env of size 0{}
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 0{}
  dest is var
Eval ?T2 in env of size 0{}
(?T2 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1044 Match!(free var)
    ?T1 == ?T2
Unify:
  s: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T3 in env of size 1{?T2: :socrates; }
  source is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
 Match(free var)!
    ?T3 == ?T3
  Equal!
  ep.src: 4
  c.src: 4
Unify:
  s: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :a(?T1, ?T2) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1046Unify:
  s: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1045    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T2 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1046Unify:
  s: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  d: :Mortal in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1045    ?T2 == ?T2
  Equal!
  ~~ match ~~ 
didn't reach top
Done euler loop
done rule checks, looping
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1047Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1046    :socrates == ?T1
Unify:
  s: :Mortal in env of size 0{}
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 0{}
-1047 Match!(free var)
    :Mortal == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(:socrates, :Mortal).3,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 0
c.rule.body.size(): 0
Q parent: Unify:
  s: :a(:socrates, :Mortal) in env of size 0{}
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: :socrates in env of size 0{}
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1048Unify:
  s: :socrates in env of size 0{}
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1047    :socrates == ?X
Unify:
  s: :Mortal in env of size 0{}
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    :Mortal == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1047 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1048Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1047    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1048 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1049Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1048    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1049 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1050Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1049    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1050Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1049    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1050Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1049    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1050 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1051Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1050    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1051 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1052Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1051    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1052 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1053Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1052    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1053 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1054Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1053    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1054 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1055Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1054    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1055 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1056Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1055    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1056Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1055    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1056Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1055    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1056 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1057Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1056    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1057 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1058Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1057    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1058 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1059Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1058    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1059 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1060Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1059    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1060 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1061Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1060    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1061 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1062Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1061    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1062Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1061    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1062Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1061    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1062 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1063Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1062    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1063 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1064Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1063    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1064 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1065Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1064    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1065 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1066Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1065    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1066 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1067Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1066    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1067 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1068Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1067    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1068Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1067    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1068Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1067    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1068 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1069Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1068    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1069 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1070Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1069    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1070 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1071Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1070    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1071 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1072Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1071    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1072 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1073Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1072    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1073 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1074Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1073    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1074Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1073    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1074Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1073    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1074 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1075Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1074    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1075 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1076Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1075    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1076 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1077Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1076    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1077 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1078Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1077    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1078 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1079Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1078    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1079 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1080Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1079    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1080Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1079    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1080Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1079    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1080 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1081Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1080    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1081 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1082Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1081    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1082 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1083Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1082    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
-1083 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1084Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1083    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :lemons in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
-1084 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
-1085Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1084    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T1 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T2: :socrates; ?T3: :Mortal; }
(?T1 is a var..)
Eval :fruit in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
-1085 Match!(free var)
    ?T1 == ?T1
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  dest is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
-1086Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  Comparison:
  Equal!
-1085    ?T2 == ?T3
  Equal!
<<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1086Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1085    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1086Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1085    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
-1086 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1087Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1086    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
Unify:
  s: :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :fruit in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }
-1087 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,0(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 2{?T1: :socrates; ?T2: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :a(?T1, ?T3) in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T1 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
-1088Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: :socrates in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  Comparison:
  Equal!
-1087    ?T2 == ?T1
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
Unify:
  s: :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
  d: ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
  dest is var
Eval ?T3 in env of size 2{?T1: :socrates; ?T2: :Mortal; }
(?T3 is a var..)
Eval :healthy food in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }
-1088 Match!(free var)
    ?T3 == ?T3
  Equal!
<<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T2, ?T3) :- :a(?T1, ?T3)5,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T2, ?T3) in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T2 is a var..)
Eval :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T2 == ?X
Unify:
  s: ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T3 in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
(?T3 is a var..)
Eval :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T3 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
=======
  c: <<:a(?T1, ?T2) :- :a(?T1, ?T3)4,1(<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,1(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} _]]) {env:env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} _]]
c.ind: 1
c.rule.body.size(): 1
Q parent: Unify:
  s: :a(?T1, ?T2) in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :a(?X, :Mortal) in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
Unify:
  s: ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T1 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T1 is a var..)
Eval :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  dest is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
-1089Unify:
  s: :socrates in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
-1088    ?T1 == ?X
Unify:
  s: ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  source is var
Eval ?T2 in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
(?T2 is a var..)
Eval :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
Unify:
  s: :Mortal in env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }
  d: :Mortal in env of size 2{?B: :lemons; ?X: :socrates; }
  Comparison:
  Equal!
    ?T2 == :Mortal
  Equal!
<<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: <<:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal)1,2(<< :- :likes(:socrates, :lemons)0,0() {env:env of size 0{}}[[ground:]]) {env:env of size 2{?B: :lemons; ?X: :socrates; }}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} _]]
c.ind: 2
c.rule.body.size(): 2
Q parent: Unify:
  s: :likes(?X, ?B) in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :likes(:socrates, :lemons) in env of size 0{}
  Comparison:
Unify:
  s: ?X in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  source is var
Eval ?X in env of size 2{?B: :lemons; ?X: :socrates; }
(?X is a var..)
Eval :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :socrates in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :socrates in env of size 0{}
  Comparison:
  Equal!
    ?X == :socrates
Unify:
  s: ?B in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  source is var
Eval ?B in env of size 2{?B: :lemons; ?X: :socrates; }
(?B is a var..)
Eval :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
Unify:
  s: :lemons in env of size 2{?B: :lemons; ?X: :socrates; }
  d: :lemons in env of size 0{}
  Comparison:
  Equal!
    ?B == :lemons
  Equal!
<< :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :healthy food; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :healthy food; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :lemons; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :Mortal; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :lemons; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :fruit; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :Mortal; ?T3: :fruit; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :Mortal; ?T3: :healthy food; }} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:socrates, :Mortal). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :socrates; ?T3: :Mortal; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :Mortal; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:lemons, :fruit). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :socrates; ?T3: :fruit; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :fruit; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
=======
  c: << :- :likes(:socrates, :lemons)0,1() {env:env of size 0{}}[[ground:_:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :lemons; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :lemons; ?T2: :healthy food; ?T3: :healthy food; }} __:a(:fruit, :healthy food). {env of size 0{}} __:a(?T2, ?T3) :- :a(?T1, ?T3) {env of size 3{?T1: :fruit; ?T2: :socrates; ?T3: :healthy food; }} __:a(?T1, ?T2) :- :a(?T1, ?T3) {env of size 3{?T1: :socrates; ?T2: :Mortal; ?T3: :healthy food; }} __:likes(?X, ?B) :- :a(?B, :healthy food):a(?X, :Mortal) {env of size 2{?B: :lemons; ?X: :socrates; }} _]]
c.ind: 1
c.rule.body.size(): 1
no parent!
Eval :likes(:socrates, :lemons) in env of size 0{}
Eval :socrates in env of size 0{}
Eval :lemons in env of size 0{}
Adding evidence for :likes: :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
evidence: 1 items...
  :likes:
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T1, ?T2), :a(?T2, ?T3), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:socrates, :Mortal), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:lemons, :fruit), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))
    :likes(:socrates, :lemons) :- GND(:a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :a(:fruit, :healthy food), :a(?T2, ?T3), :a(?T1, ?T2), :likes(?X, ?B))

---
